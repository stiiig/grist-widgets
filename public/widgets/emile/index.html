<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>EMILE – Fiche candidat (édition)</title>

  <!-- DSFR 1.14 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@gouvfr/dsfr@1.14/dist/dsfr.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@gouvfr/dsfr@1.14/dist/icons/icons.min.css">
  <script type="module" src="https://cdn.jsdelivr.net/npm/@gouvfr/dsfr@1.14/dist/dsfr.module.min.js"></script>

  <style>
    body { margin: 0; }
    .container { padding: 6px; }
    .sticky { position: sticky; top: 0; background: white; padding-bottom: 4px; z-index: 200; }
    .grow { flex: 1; min-width: 220px; }
    .muted { color: var(--text-mention-grey); }
    .pill { display:inline-flex; align-items:center; padding: 2px 10px; border-radius: 999px; background: var(--background-alt-grey); font-size: 0.8rem; }
    .fr-error-text[hidden]{ display:none !important; }
    .field-row { margin-bottom: 6px; }

    /* Dropdown search (autocomplete) */
    .dd-wrap { position: relative; }
    .dd-list {
      position:absolute; left:0; right:0; top: calc(100% + 3px);
      border:1px solid var(--border-default-grey); background:white; border-radius: 8px;
      max-height: 240px; overflow:auto; z-index: 500;
      box-shadow: 0 6px 18px rgba(0,0,0,.08);
      font-size: 0.82rem;
    }
    .dd-item { padding: 8px 10px; cursor:pointer; }
    .dd-item:hover { background: var(--background-alt-grey); }
    .dd-item small { display:block; color: var(--text-mention-grey); font-size: 0.74rem; }

    /* Ultra-compact */
    .fr-label { font-size: 0.85rem; }
    .fr-hint-text { font-size: 0.72rem; }
    .fr-input, .fr-select { padding-top: 0.35rem; padding-bottom: 0.35rem; }
    .fr-btn.fr-btn--sm { padding: 0.25rem 0.6rem; font-size: 0.85rem; }

    /* Padding autour du titre EMILE */
    .toolbar h2 { padding-left: 8px; padding-right: 8px; }

    /* Tag ID candidat */
    .id-tag {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 8px;
      border-radius: 999px;
      background: var(--background-alt-blue-france);
      color: var(--text-title-blue-france);
      font-size: 0.75rem;
      font-weight: 500;
      margin-left: 8px;
      white-space: nowrap;
      cursor: pointer;
    }
    .id-tag:hover { background: var(--background-alt-blue-france-hover); }

    /* Hint popover */
    .hint-wrap { position: relative; display: inline-flex; align-items: center; gap: 4px; }
    .hint-btn { line-height: 1; padding: 0; min-height: auto; }
    .hint-btn,
    .hint-btn:hover,
    .hint-btn:focus,
    .hint-btn:active {
      background: transparent !important;
      box-shadow: none !important;
    }
    .hint-pop {
      position: absolute;
      top: calc(100% + 4px);
      right: 0;
      width: max-content;
      max-width: 260px;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--border-default-grey);
      background: var(--background-default-grey);
      box-shadow: 0 6px 18px rgba(0,0,0,.10);
      font-size: 0.78rem;
      color: var(--text-default-grey);
      z-index: 600;
    }
    .hint-pop[hidden]{ display:none !important; }
    .hint-pop:before{
      content:"";
      position:absolute;
      top:-6px; right: 10px;
      width: 10px; height: 10px;
      background: var(--background-default-grey);
      border-left: 1px solid var(--border-default-grey);
      border-top: 1px solid var(--border-default-grey);
      transform: rotate(45deg);
    }

    /* Picto ? custom */
    .hint-q{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      font-size: 0.75rem;
      font-weight: 700;
      color: var(--text-action-high-blue-france);
      background: var(--background-alt-blue-france);
    }

    /* Inputs compacts */
    .fr-input, .fr-select, textarea.fr-input { font-size: 0.85rem; }

    /* Ultra dense */
    .ultra-dense { gap: 4px !important; }
    .ultra-dense .field-row { margin-bottom: 4px !important; }
    .ultra-dense .fr-input,
    .ultra-dense .fr-select,
    .ultra-dense textarea.fr-input {
      font-size: 0.82rem;
      padding-top: 0.20rem;
      padding-bottom: 0.20rem;
    }
    .ultra-dense .fr-label { margin-bottom: 0.15rem; }

    /* Pieces jointes compact */
    .att-row { display:flex; align-items:center; gap:6px; flex-wrap:wrap; margin-top: 4px; }
    .att-file { display: none; }
    .att-btn { padding: 0.18rem 0.5rem !important; min-height: auto !important; line-height: 1.1; }
    .att-btn-primary { padding: 0.18rem 0.5rem !important; min-height: auto !important; line-height: 1.1; }

    /* Tags PJ interactifs */
    .att-tag-btn { border: 0; background: transparent; padding: 0; margin: 0; cursor: pointer; max-width: 260px; }
    .att-tag {
      display:inline-flex; align-items:center; gap:6px;
      padding: 2px 6px; border-radius: 999px;
      background: var(--background-alt-grey); color: var(--text-default-grey);
      font-size: 0.7rem; line-height: 1.2;
      max-width: 260px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .att-tag:hover { background: var(--background-alt-grey-hover); }
    .att-tag:active { background: var(--background-alt-grey-active); }
    .att-tag-name { overflow:hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 220px; display:inline-block; }
    .att-tag-remove {
      display:inline-flex; align-items:center; justify-content:center;
      width: 16px; height: 16px; border-radius: 50%;
      font-size: 0.8rem; line-height: 1;
      color: var(--text-default-grey); background: transparent; border: 0; cursor: pointer; flex: 0 0 auto;
    }
    .att-tag-remove:hover { background: rgba(0,0,0,.06); }

    /* Choice/ChoiceList : input en mode selecteur */
    .no-search { cursor: pointer; }

    /* Footer */
    .emile-footer {
      margin-top: 14px;
      border-top: 1px solid var(--border-default-grey);
      padding: 10px 0;
      text-align:center;
      color: var(--text-mention-grey);
      font-size: 0.85rem;
    }

    /* ID2 en petit dans la liste candidats */
    .cand-id2 {
      display:block;
      font-size: 0.7rem;
      color: var(--text-mention-grey);
      margin-top: 2px;
    }

    /* Bouton clear recherche */
    .clear-btn { margin-left: 4px; color: var(--text-default-grey); font-size: 0.9rem; }
    .clear-btn:hover { background: var(--background-alt-grey-hover); }
    .clear-btn[hidden] { display:none !important; }

    /* Clear dans le champ recherche */
    .search-wrap { position: relative; width: 100%; }
    .search-wrap #candidateSearch { padding-right: 30px; }
    .search-wrap .clear-btn {
      position: absolute; right: 6px; top: 50%; transform: translateY(-50%);
      width: 18px; height: 18px; border-radius: 50%;
      display: inline-flex; align-items: center; justify-content: center; font-size: 0.9rem;
    }

    /* DSFR layout & composants */
    .toolbar { display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap; }
    .toolbar .grow { flex: 1 1 320px; }
    .toolbar .fr-tags-group { margin:0; }
    .toolbar .fr-btns-group { margin:0; }

    /* Tags selection + ID en bleu */
    #selectedPill.fr-tag,
    #candidateIdTag.fr-tag {
      background-color: var(--background-contrast-info);
      color: var(--text-default-info);
      border: 1px solid var(--border-default-info);
    }

    /* Fallback si la feuille d'icones n'est pas chargee */
    #selectedPill.fr-tag[class*="fr-icon-"]::before,
    #candidateIdTag.fr-tag[class*="fr-icon-"]::before { content: none !important; }

    /* Accordeons : un peu d'air */
    .fr-accordion__btn { padding-top: .75rem; padding-bottom: .75rem; }

    /* Toggle Bool compact */
    .field-row .fr-toggle { margin-top: 0.25rem; }

    /* ===== TABS: onglets horizontaux ===== */
    .fr-tabs__list {
      overflow-x: auto;
      flex-wrap: nowrap;
      scrollbar-width: thin;
    }
    .fr-tabs__tab {
      white-space: nowrap;
      font-size: 0.82rem;
      padding: 0.5rem 0.75rem;
    }

    /* ===== SUB-SECTION TAGS ===== */
    .sub-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 1rem;
      padding: 0.5rem 0;
      border-bottom: 1px solid var(--border-default-grey);
    }
    .sub-tag {
      cursor: pointer;
      transition: background-color 0.2s, color 0.2s;
      border: none;
      font-size: 0.82rem;
    }
    .sub-tag--active {
      background-color: var(--background-action-high-blue-france) !important;
      color: var(--text-inverted-blue-france) !important;
    }
    .sub-tag--empty { opacity: 0.6; }

    /* Zone de contenu sous-section */
    .sub-content { display: none; }
    .sub-content--active { display: block; }

    /* Champs lecture seule */
    .field-readonly .fr-input,
    .field-readonly .fr-select,
    .field-readonly .fr-toggle__input {
      background-color: var(--background-alt-grey);
      cursor: not-allowed;
      opacity: 0.7;
    }
    .field-readonly .fr-toggle__label { opacity: 0.7; }
    .field-readonly::after {
      content: "Lecture seule";
      display: block;
      font-size: 0.7rem;
      color: var(--text-mention-grey);
      margin-top: 2px;
      font-style: italic;
    }

    /* Callout sous-section vide */
    .sub-empty-callout {
      margin: 1rem 0;
    }
    .sub-empty-callout .fr-callout__text {
      font-size: 0.85rem;
    }

    /* Card header dans formRoot */
    .form-header-card {
      margin-bottom: 1rem;
    }
  </style>

  <script src="https://docs.getgrist.com/grist-plugin-api.js"></script>
</head>

<body>
  <div class="container">
    <div class="sticky">
      <div class="toolbar">
        <h2 class="fr-h5" style="margin:0;">EMILE</h2>

        <div class="grow">
          <div class="fr-input-group" style="margin:0;">
            <div class="dd-wrap">
              <div class="search-wrap">
                <input id="candidateSearch" class="fr-input" placeholder="Rechercher un candidat…" autocomplete="off" />
                <button type="button" id="clearSearchBtn" class="hint-btn clear-btn" aria-label="Effacer" hidden>×</button>
              </div>
              <div id="candidateList" class="dd-list" hidden></div>
            </div>
          </div>
        </div>

        <div class="fr-tags-group" aria-label="Sélection">
          <p class="fr-tag fr-tag--sm fr-tag--icon-left fr-icon-user-line" id="selectedPill" role="status" aria-live="polite">
            Aucun candidat sélectionné
          </p>
        </div>

        <div class="fr-btns-group fr-btns-group--inline-reverse fr-btns-group--inline-lg" style="margin:0;">
          <button id="saveBtn" class="fr-btn fr-btn--sm" type="button" disabled>Enregistrer</button>
        </div>
        <span id="status" class="muted"></span>
      </div>

      <div id="alertBox" class="fr-alert fr-alert--success" role="alert" hidden style="margin-top:12px;">
        <p class="fr-alert__title">Enregistré</p>
        <p id="alertText" class="fr-alert__desc">Les modifications ont été enregistrées.</p>
        <button id="closeAlert" class="fr-btn fr-btn--tertiary-no-outline fr-btn--sm" type="button">Fermer</button>
      </div>

      <hr style="margin: 6px 0 0 0;">
    </div>

    <div style="margin-top:16px;">
      <div id="emptyState" class="fr-callout">
        <p class="fr-callout__title">Sélectionne un candidat</p>
        <p class="fr-callout__text">Utilise la recherche en haut pour afficher et modifier la fiche.</p>
      </div>

      <div id="formRoot" hidden>
        <!-- Header card with candidate ID -->
        <div class="fr-card fr-card--no-arrow form-header-card">
          <div class="fr-card__body"><div class="fr-card__content">
            <div class="fr-grid-row fr-grid-row--middle fr-grid-row--gutters">
              <div class="fr-col"><h2 class="fr-card__title fr-text--lg" style="margin:0;">Dossier</h2></div>
              <div class="fr-col fr-col--right">
                <p class="fr-tag fr-tag--sm fr-tag--icon-left fr-icon-hashtag" id="candidateIdTag" hidden style="margin:0;">
                  ID&nbsp;: <span id="candidateIdValue"></span>
                </p>
              </div>
            </div>
            <p class="fr-card__desc">Informations et documents du candidat.</p>
          </div></div>
        </div>

        <!-- Onglets DSFR (générés dynamiquement en JS) -->
        <div id="tabsContainer"></div>
      </div>
    </div>
  </div>

  <footer class="emile-footer">
    <span>Programme EMILE (Engagés pour la Mobilité et l'Insertion par le Logement et l'Emploi)</span>
  </footer>


<script>
(() => {
  const TABLE_ID = "CANDIDATS";

  /* ===== 10 onglets avec sous-sections ===== */
  const TABS = [
    { id: "administratif", label: "Administratif", icon: "fr-icon-building-line", sections: [
      { id: "admin-perso",   label: "Informations personnelles", cols: ["Prenom","Nom_de_famille","Date_de_naissance","Age","Genre","Nationalite","Majeur","AIE","Niveau_de_langue","Niveau_etudes_reconnu_en_France","PMR","RQTH"] },
      { id: "admin-coord",   label: "Coordonnées",               cols: ["Adresse","Email","Tel","Departement_domicile_inscription"] },
      { id: "admin-sitadmin",label: "Situation administrative",   cols: ["Regularite_situation","Date_validite_titre_sejour","Numero_unique_enregistrement"] },
      { id: "admin-besoins", label: "Besoins particuliers",       cols: [] },
      { id: "admin-comp",    label: "Compléments",                cols: ["Motivation_candidat","Autres_initiatives_perso"] },
    ]},
    { id: "dls", label: "DLS", icon: "fr-icon-key-line", sections: [
      { id: "dls-statut",    label: "Statut de la demande",       cols: ["Commentaire_du_statut"] },
      { id: "dls-pieces",    label: "Pièces administratives",     cols: ["Attestation_MSA_CAF","Document_identite_sejour_candidats","Document_identite_sejour_autres_personnes"] },
      { id: "dls-revenus",   label: "Justificatifs de revenus",   cols: [] },
      { id: "dls-comp",      label: "Compléments",                cols: [] },
    ]},
    { id: "emploi", label: "Emploi-Formation", icon: "fr-icon-briefcase-line", sections: [
      { id: "emploi-sit",    label: "Situation actuelle",          cols: [] },
      { id: "emploi-projet", label: "Projet candidat·e",          cols: [] },
      { id: "emploi-demarche",label:"Démarches engagées",         cols: [] },
      { id: "emploi-cv",     label: "CV et attestations",         cols: [] },
      { id: "emploi-besoins",label: "Besoins particuliers",       cols: ["Situation_face_emploi"] },
      { id: "emploi-comp",   label: "Compléments",                cols: ["Complement_info_Emploi_Formation"] },
    ]},
    { id: "finances", label: "Finances", icon: "fr-icon-money-euro-circle-line", sections: [
      { id: "fin-sit",       label: "Situation actuelle",          cols: ["Situation_financiere"] },
      { id: "fin-ft",        label: "France Travail",              cols: [] },
      { id: "fin-avis",      label: "Avis et attestations",       cols: [] },
      { id: "fin-comp",      label: "Compléments",                cols: ["Complement_info_Finances"] },
    ]},
    { id: "foyer", label: "Foyer", icon: "fr-icon-team-line", sections: [
      { id: "foyer-compo",   label: "Composition",                cols: [] },
      { id: "foyer-couple",  label: "Couple / famille",           cols: [] },
      { id: "foyer-besoins", label: "Besoins particuliers",       cols: ["Besoin_prise_en_charge_enfant_s_","Besoin_accompagner_conjoint_e_vers_emploi_formation"] },
      { id: "foyer-comp",    label: "Compléments",                cols: [] },
    ]},
    { id: "habitat", label: "Habitat", icon: "fr-icon-home-4-line", sections: [
      { id: "hab-general",   label: "Informations générales",     cols: [] },
      { id: "hab-etape",     label: "Situation par étape",        cols: ["Situation_hebergement"] },
      { id: "hab-attquitt",  label: "Attestation, avis et quittances", cols: [] },
      { id: "hab-coloc",     label: "Colocation",                 cols: [] },
      { id: "hab-besoins",   label: "Besoins particuliers",       cols: ["Precarite_de_logement","Besoin_mise_a_l_abri"] },
      { id: "hab-comp",      label: "Compléments",                cols: [] },
    ]},
    { id: "lec", label: "Lecture-Écriture-Calcul", icon: "fr-icon-book-2-line", sections: [
      { id: "lec-general",   label: "Informations générales",     cols: [] },
      { id: "lec-francais",  label: "Maîtrise du français",       cols: ["Niveau_de_langue"] },
      { id: "lec-calcul",    label: "Calcul",                     cols: [] },
      { id: "lec-apprenti",  label: "Apprentissages",             cols: [] },
      { id: "lec-comp",      label: "Compléments",                cols: [] },
    ]},
    { id: "mobilite", label: "Mobilité", icon: "fr-icon-car-line", sections: [
      { id: "mob-vehicules", label: "Véhicules, code et permis",  cols: ["Vehicule","Permis"] },
      { id: "mob-besoins",   label: "Besoins particuliers",       cols: [] },
      { id: "mob-comp",      label: "Compléments",                cols: ["Complement_info_Mobilite"] },
    ]},
    { id: "numerique", label: "Numérique", icon: "fr-icon-computer-line", sections: [
      { id: "num-materiel",  label: "Matériel et capacités",      cols: [] },
      { id: "num-besoins",   label: "Besoins particuliers",       cols: [] },
      { id: "num-comp",      label: "Compléments",                cols: [] },
    ]},
    { id: "sante", label: "Santé", icon: "fr-icon-heart-pulse-line", sections: [
      { id: "san-sit",       label: "Situation actuelle",          cols: [] },
      { id: "san-docs",      label: "Documents",                  cols: [] },
      { id: "san-besoins",   label: "Besoins particuliers",       cols: ["Besoin_divers","Difficultes_diverses"] },
      { id: "san-comp",      label: "Compléments",                cols: [] },
    ]},
  ];

  /** Colonnes qui apparaissent dans 2 sous-sections : readonly dans les sections listées ici */
  const READONLY_IN = {
    "Niveau_de_langue": new Set(["lec-francais"]),
  };

  /* ===== State ===== */
  let docApi;
  let columnsMeta = [];
  let selectedRowId = null;
  let selectedRecord = null;
  let candidatesIndex = [];
  let tableCache = null;
  let refsCache = new Map();
  let attachmentsNameById = new Map();
  let gristColIdByRowId = new Map();
  let gristTableIdByParentId = new Map();
  let tabsBuilt = false;

  const $ = (id) => document.getElementById(id);

  /* ===== UI helpers ===== */
  function setStatus(msg) { $("status").textContent = msg || ""; }
  function showAlert(text) { $("alertText").textContent = text || "Enregistré."; $("alertBox").hidden = false; }
  function hideAlert() { $("alertBox").hidden = true; }
  function setSelectedPill(label) { $("selectedPill").textContent = label ? `Sélection : ${label}` : "Aucun candidat sélectionné"; }

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, (c) => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[c]));
  }

  /* ===== Dropdown helpers ===== */

  /** Ferme toutes les listes dropdown sauf `except` */
  function closeAllLists(except) {
    for (const l of document.querySelectorAll(".dd-list")) {
      if (except && l === except) continue;
      l.hidden = true;
    }
    if (except) except.hidden = false;
  }

  document.addEventListener("pointerdown", (e) => {
    const path = (typeof e.composedPath === "function") ? e.composedPath() : null;
    const inside = (path && path.some(n => n && n.classList && n.classList.contains("dd-wrap")))
      || (e.target && e.target.closest && e.target.closest(".dd-wrap"));
    if (!inside) closeAllLists(null);
  }, { capture: true });

  /**
   * Configure le comportement d'un input dropdown (searchable ou click-to-select).
   */
  function setupDropdownBehavior(input, renderFn, isSearchable) {
    if (isSearchable) {
      input.readOnly = false;
      input.placeholder = "Rechercher…";
      input.addEventListener("focus", () => renderFn(input.value));
      input.addEventListener("click", () => renderFn(input.value));
      input.addEventListener("input", () => renderFn(input.value));
    } else {
      input.readOnly = true;
      input.classList.add("no-search");
      input.placeholder = "Sélectionner…";
      input.addEventListener("focus", () => renderFn(""));
      input.addEventListener("click", () => renderFn(""));
    }
  }

  /**
   * Cree un element dd-item (ligne de dropdown).
   */
  function createDropdownItem(item, onSelect) {
    const div = document.createElement("div");
    div.className = "dd-item";
    let inner = "";
    if (item.hasCheckbox) {
      inner = `<div style="display:flex; gap:8px; align-items:center;">
        <input type="checkbox" ${item.checked ? "checked" : ""} aria-label="Sélectionner">
        <span>${escapeHtml(item.label)}</span>
      </div>`;
    } else {
      inner = `<div>${escapeHtml(item.label)}</div>`;
    }
    if (item.extra) inner += `<small class="cand-id2">${escapeHtml(item.extra)}</small>`;
    div.innerHTML = inner;
    div.addEventListener("pointerdown", (ev) => {
      ev.preventDefault();
      onSelect();
    });
    return div;
  }

  /* ===== Grist list cell encoding ===== */
  function isListCell(v) { return Array.isArray(v) && v[0] === "L"; }
  function decodeListCell(v) { return isListCell(v) ? v.slice(1) : (v == null ? [] : Array.isArray(v) ? v : [v]); }
  function encodeListCell(arr) { return ["L", ...(arr || [])]; }

  /* ===== Attachments map ===== */
  async function refreshAttachmentsMap() {
    try {
      const at = await docApi.fetchTable("_grist_Attachments");
      const m = new Map();
      if (at && at.id) {
        const nameCol = at.fileName || at.name || at.FileName || at.filename;
        for (let i = 0; i < at.id.length; i++) {
          const id = at.id[i];
          const nm = nameCol ? nameCol[i] : null;
          if (id != null && nm != null) m.set(id, String(nm));
        }
      }
      attachmentsNameById = m;
    } catch (e) {
      console.warn("Cannot read _grist_Attachments", e);
    }
  }

  /* ===== Column metadata helpers ===== */
  function parseWidgetOptions(str) {
    if (!str) return {};
    try { return JSON.parse(str); } catch { return {}; }
  }

  function parseRefType(typeStr) {
    const m1 = /^Ref:(.+)$/.exec(typeStr);
    if (m1) return { kind: "Ref", tableId: m1[1] };
    const m2 = /^RefList:(.+)$/.exec(typeStr);
    if (m2) return { kind: "RefList", tableId: m2[1] };
    return null;
  }

  function normalizeChoices(raw) {
    if (!raw) return [];
    if (Array.isArray(raw)) return raw.map(x => (x == null ? "" : String(x))).filter(Boolean);
    if (typeof raw === "string") return raw.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    return [];
  }

  function getChoiceOptions(col) {
    const wopts = col.widgetOptionsParsed || {};
    const opts1 = normalizeChoices(wopts.choices);
    if (opts1.length) return Array.from(new Set(opts1)).sort((a, b) => a.localeCompare(b));

    if (tableCache && tableCache[col.colId]) {
      const vals = tableCache[col.colId];
      const set = new Set();
      for (const v of vals) {
        if (v == null) continue;
        const s = String(v).trim();
        if (!s) continue;
        set.add(s);
        if (set.size >= 400) break;
      }
      return Array.from(set).sort((a, b) => a.localeCompare(b));
    }
    return [];
  }

  async function loadColumnsMetaFor(tableId) {
    const tables = await docApi.fetchTable("_grist_Tables");
    const idx = tables.tableId.findIndex(t => t === tableId);
    if (idx < 0) throw new Error(`Table introuvable: ${tableId}`);
    const parentId = tables.id[idx];

    const cols = await docApi.fetchTable("_grist_Tables_column");
    const res = [];
    for (let i = 0; i < cols.id.length; i++) {
      if (cols.parentId[i] !== parentId) continue;
      const colId = cols.colId[i];
      if (!colId) continue;
      const rawOpts = cols.widgetOptions[i] || "";
      res.push({
        colId,
        label: cols.label[i] || colId,
        type: cols.type[i] || "Text",
        widgetOptions: rawOpts,
        widgetOptionsParsed: parseWidgetOptions(rawOpts),
        isFormula: !!cols.isFormula[i],
        description: (cols.description ? (cols.description[i] || "") : ""),
        visibleColRowId: (cols.visibleCol ? cols.visibleCol[i] : null),
        displayColRowId: (cols.displayCol ? cols.displayCol[i] : null)
      });
    }
    res.sort((a, b) => a.colId.localeCompare(b.colId));
    return res;
  }

  function isEditable(col) {
    if (col.isFormula) return false;
    const ban = new Set(["id", "manualSort", "ManualSort", "CreatedAt", "UpdatedAt"]);
    return !ban.has(col.colId);
  }

  /* ===== Ref cache ===== */
  async function ensureRefCache(col) {
    const parsed = parseRefType(col.type);
    if (!parsed || (parsed.kind !== "Ref" && parsed.kind !== "RefList")) return null;
    if (refsCache.has(col.colId)) return refsCache.get(col.colId);

    const t = await docApi.fetchTable(parsed.tableId);
    const colNames = Object.keys(t).filter(k => k !== "id");

    let displayFromMeta = null;
    const rowId = (col.visibleColRowId || col.displayColRowId);
    if (typeof rowId === "number") {
      const meta = gristColIdByRowId.get(rowId);
      if (meta && meta.colId) displayFromMeta = meta.colId;
    }

    const wopts = col.widgetOptionsParsed || {};
    const displayFromOptions = wopts.visibleCol || wopts.displayCol || wopts.showColumn || wopts.visibleColumn;
    const candidate = displayFromMeta || (displayFromOptions && String(displayFromOptions)) || null;
    const displayCol = (candidate && colNames.includes(candidate)) ? candidate : colNames[0];

    const EXTRA_PREFS = {
      "PAYS": ["Type_de_nationalite", "Type_de_nationalité", "Type_nationalite", "Type", "Categorie", "Catégorie"],
      "DPTS_REGIONS": ["Nom_region", "Nom_région", "Region", "Région", "NomRegion", "Libelle_region", "Libellé_région"],
      "ETABLISSEMENTS": ["Departement", "Département", "Dpt", "DEP", "Code_departement", "Code_département"],
      "ACCOMPAGNANTS": ["Fonction", "Role", "Rôle", "Metier", "Métier", "Poste"],
    };

    let extraCol = null;
    const prefs = EXTRA_PREFS[parsed.tableId];
    if (prefs && prefs.length) {
      extraCol = prefs.find(c => colNames.includes(c)) || null;
    }

    const rows = [];
    const byId = new Map();
    for (let i = 0; i < t.id.length; i++) {
      const id = t.id[i];
      const label = (t[displayCol]?.[i] ?? `${id}`).toString();
      const extra = extraCol ? (t[extraCol]?.[i] ?? "") : "";
      const item = { id, label, extra: (extra == null ? "" : String(extra)).trim(), q: (label + " " + id).toLowerCase() };
      rows.push(item);
      byId.set(id, item);
    }

    const cache = { tableId: parsed.tableId, displayCol, rows, byId };
    refsCache.set(col.colId, cache);
    return cache;
  }

  /* ===== Candidate search dropdown ===== */
  function buildCandidateIndexFromTable(t) {
    const ids = t.id || [];
    const nomCol = t["Nom_de_famille"] || [];
    const prenomCol = t["Prenom"] || [];
    const id2Col = t["ID2"] || [];
    const res = [];
    for (let i = 0; i < ids.length; i++) {
      const id = ids[i];
      const nom = (nomCol[i] ?? "").toString();
      const prenom = (prenomCol[i] ?? "").toString();
      const id2 = (id2Col[i] ?? "").toString().trim();
      const label = `${prenom} ${nom}`.trim() || `#${id}`;
      const q = `${nom} ${prenom} ${id2} ${id}`.toLowerCase().trim();
      res.push({ id, label, extra: id2 || "", q });
    }
    res.sort((a, b) => a.label.localeCompare(b.label));
    return res;
  }

  function renderCandidateMatches(q) {
    const list = $("candidateList");
    list.innerHTML = "";
    const qq = (q || "").toLowerCase().trim();
    const matches = qq ? candidatesIndex.filter(c => c.q.includes(qq)).slice(0, 25) : candidatesIndex.slice(0, 25);

    if (matches.length === 0) {
      list.appendChild(createDropdownItem({ label: "Aucun résultat", extra: "Affiner la recherche" }, () => {}));
      closeAllLists(list);
      return;
    }

    for (const m of matches) {
      list.appendChild(createDropdownItem({ label: m.label, extra: m.extra }, () => {
        $("candidateSearch").value = m.label;
        if (typeof syncClearBtn === "function") syncClearBtn();
        closeAllLists(null);
        loadCandidate(m.id);
      }));
    }
    closeAllLists(list);
  }

  /* ==========================================================================
   *  TABS & SUB-SECTIONS — Construction dynamique des onglets DSFR
   * ========================================================================== */

  /**
   * Construit le squelette HTML fr-tabs à partir de la constante TABS.
   * Appelé une seule fois au démarrage.
   */
  function buildTabs() {
    const container = $("tabsContainer");
    container.innerHTML = "";

    const tabsDiv = document.createElement("div");
    tabsDiv.className = "fr-tabs";

    // --- Tab list (ul) ---
    const ul = document.createElement("ul");
    ul.className = "fr-tabs__list";
    ul.setAttribute("role", "tablist");
    ul.setAttribute("aria-label", "Sections du dossier");

    for (let i = 0; i < TABS.length; i++) {
      const tab = TABS[i];
      const li = document.createElement("li");
      li.setAttribute("role", "presentation");

      const btn = document.createElement("button");
      btn.id = `tab-${tab.id}`;
      btn.className = "fr-tabs__tab";
      if (tab.icon) btn.classList.add(tab.icon);
      btn.setAttribute("role", "tab");
      btn.setAttribute("aria-controls", `panel-${tab.id}`);
      btn.setAttribute("aria-selected", i === 0 ? "true" : "false");
      btn.setAttribute("tabindex", i === 0 ? "0" : "-1");
      btn.textContent = tab.label;

      li.appendChild(btn);
      ul.appendChild(li);
    }

    tabsDiv.appendChild(ul);

    // --- Panels ---
    for (let i = 0; i < TABS.length; i++) {
      const tab = TABS[i];
      const panel = document.createElement("div");
      panel.id = `panel-${tab.id}`;
      panel.className = `fr-tabs__panel${i === 0 ? " fr-tabs__panel--selected" : ""}`;
      panel.setAttribute("role", "tabpanel");
      panel.setAttribute("aria-labelledby", `tab-${tab.id}`);
      panel.setAttribute("tabindex", "0");

      // Sub-section tags
      const tagsDiv = document.createElement("div");
      tagsDiv.className = "sub-tags";
      tagsDiv.id = `tags-${tab.id}`;

      for (let j = 0; j < tab.sections.length; j++) {
        const sec = tab.sections[j];
        const tag = document.createElement("button");
        tag.type = "button";
        tag.className = `fr-tag fr-tag--sm sub-tag${j === 0 ? " sub-tag--active" : ""}`;
        tag.dataset.sectionId = sec.id;
        tag.dataset.tabId = tab.id;
        tag.textContent = sec.label;

        tag.addEventListener("click", () => {
          showSubSection(tab.id, sec.id);
        });

        tagsDiv.appendChild(tag);
      }

      panel.appendChild(tagsDiv);

      // Content zones for each sub-section
      for (let j = 0; j < tab.sections.length; j++) {
        const sec = tab.sections[j];
        const content = document.createElement("div");
        content.className = `sub-content${j === 0 ? " sub-content--active" : ""}`;
        content.id = `content-${sec.id}`;

        // Fields container (grid)
        const grid = document.createElement("div");
        grid.className = "fr-grid-row fr-grid-row--gutters";
        grid.id = `fields-${sec.id}`;
        content.appendChild(grid);

        panel.appendChild(content);
      }

      tabsDiv.appendChild(panel);
    }

    container.appendChild(tabsDiv);
    tabsBuilt = true;
  }

  /**
   * Affiche une sous-section donnée dans un onglet, masque les autres.
   */
  function showSubSection(tabId, sectionId) {
    // Update tags active state
    const tagsContainer = $(`tags-${tabId}`);
    if (tagsContainer) {
      for (const tag of tagsContainer.querySelectorAll(".sub-tag")) {
        tag.classList.toggle("sub-tag--active", tag.dataset.sectionId === sectionId);
      }
    }

    // Show/hide content zones
    const panel = $(`panel-${tabId}`);
    if (panel) {
      for (const c of panel.querySelectorAll(".sub-content")) {
        c.classList.toggle("sub-content--active", c.id === `content-${sectionId}`);
      }
    }
  }

  /* ==========================================================================
   *  TYPE HANDLERS — un handler par type de colonne Grist
   * ========================================================================== */

  /** Attachments : upload/download/suppression de fichiers */
  function renderAttachmentsField(ctx) {
    const { col, current, setValueToState, label, group, wrap } = ctx;

    const list = document.createElement("ul");
    list.style.cssText = "padding-left:16px; margin-top:6px; margin-bottom:6px;";

    function cellToIds(cell) {
      const ids = isListCell(cell) ? decodeListCell(cell) : (Array.isArray(cell) ? cell : []);
      return ids.filter(x => typeof x === "number");
    }
    function fileLabel(id) { return attachmentsNameById.get(id) || `#${id}`; }

    function renderIds(ids) {
      list.innerHTML = "";
      if (!ids.length) {
        const li = document.createElement("li");
        li.className = "muted";
        li.textContent = "Aucune pièce jointe.";
        list.appendChild(li);
        return;
      }
      const tagsWrap = document.createElement("div");
      tagsWrap.className = "att-tags";

      for (const id of ids) {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "att-tag-btn";
        btn.title = "Ouvrir / télécharger";

        const pill = document.createElement("span");
        pill.className = "att-tag";

        const name = document.createElement("span");
        name.className = "att-tag-name";
        name.textContent = fileLabel(id);

        const remove = document.createElement("button");
        remove.type = "button";
        remove.className = "att-tag-remove";
        remove.title = "Supprimer";
        remove.setAttribute("aria-label", "Supprimer la pièce jointe");
        remove.textContent = "×";

        btn.addEventListener("click", async () => {
          try {
            const tokenInfo = await docApi.getAccessToken({ readOnly: false });
            const url = `${tokenInfo.baseUrl}/attachments/${id}/download?auth=${tokenInfo.token}`;
            window.open(url, "_blank", "noopener");
          } catch (e) {
            console.error(e);
            setStatus("Impossible d'ouvrir la pièce jointe (voir console).");
          }
        });

        remove.addEventListener("click", async (ev) => {
          ev.stopPropagation();
          ev.preventDefault();
          try {
            if (!selectedRowId) return;
            const t = tableCache || await docApi.fetchTable(TABLE_ID);
            const idx = t.id.findIndex(x => x === selectedRowId);
            const existingCell = idx >= 0 ? t[col.colId][idx] : null;
            const existingIds = cellToIds(existingCell);
            const merged = existingIds.filter(x => x !== id);
            await docApi.applyUserActions([["UpdateRecord", TABLE_ID, selectedRowId, { [col.colId]: ["L", ...merged] }]]);
            await refreshAttachmentsMap();
            setValueToState(["L", ...merged]);
            currentIds = merged;
            renderIds(currentIds);
            showAlert("Pièce jointe supprimée.");
          } catch (e) {
            console.error(e);
            setStatus("Erreur suppression PJ (voir console).");
          }
        });

        pill.appendChild(name);
        pill.appendChild(remove);
        btn.appendChild(pill);
        tagsWrap.appendChild(btn);
      }
      list.appendChild(tagsWrap);
    }

    let currentIds = cellToIds(current);
    renderIds(currentIds);

    const row = document.createElement("div");
    row.className = "att-row";

    const fileInput = document.createElement("input");
    fileInput.type = "file";
    fileInput.multiple = true;
    fileInput.className = "att-file";
    fileInput.setAttribute("aria-label", "Choisir des fichiers");

    const miniBtn = document.createElement("button");
    miniBtn.type = "button";
    miniBtn.className = "fr-btn fr-btn--tertiary-no-outline fr-btn--sm att-btn";
    miniBtn.textContent = "Ajouter";

    const selInfo = document.createElement("span");
    selInfo.className = "fr-text--xs muted";
    selInfo.textContent = "";

    const uploadBtn = document.createElement("button");
    uploadBtn.type = "button";
    uploadBtn.className = "fr-btn fr-btn--sm att-btn-primary";
    uploadBtn.textContent = "OK";
    uploadBtn.title = "Uploader les fichiers sélectionnés";
    uploadBtn.disabled = true;

    fileInput.addEventListener("change", () => {
      const n = (fileInput.files || []).length;
      selInfo.textContent = n ? `${n} fichier(s) sélectionné(s)` : "";
      uploadBtn.disabled = !n;
    });

    miniBtn.addEventListener("click", () => fileInput.click());

    uploadBtn.addEventListener("click", async () => {
      try {
        const files = Array.from(fileInput.files || []);
        if (!files.length) { setStatus("Sélectionne au moins un fichier."); return; }
        if (!selectedRowId) { setStatus("Sélectionne d'abord un candidat."); return; }

        setStatus("Upload des pièces jointes…");
        const tokenInfo = await docApi.getAccessToken({ readOnly: false });
        const newIds = [];

        for (const file of files) {
          const formData = new FormData();
          formData.append("upload", file, file.name);
          const resp = await fetch(`${tokenInfo.baseUrl}/attachments?auth=${tokenInfo.token}`, {
            method: "POST", body: formData,
            headers: { "X-Requested-With": "XMLHttpRequest" },
          });
          if (!resp.ok) {
            const t = await resp.text().catch(() => "");
            throw new Error(`Upload échoué (${resp.status}) ${t}`);
          }
          const result = await resp.json();
          const attId = Array.isArray(result) ? result[0] : null;
          if (typeof attId !== "number") throw new Error("Réponse upload inattendue.");
          newIds.push(attId);
        }

        const t = tableCache || await docApi.fetchTable(TABLE_ID);
        const idx = t.id.findIndex(x => x === selectedRowId);
        const existingCell = idx >= 0 ? t[col.colId][idx] : null;
        const existingIds = cellToIds(existingCell);
        const merged = [...existingIds, ...newIds];
        await docApi.applyUserActions([["UpdateRecord", TABLE_ID, selectedRowId, { [col.colId]: ["L", ...merged] }]]);

        await refreshAttachmentsMap();
        setValueToState(["L", ...merged]);
        currentIds = merged;
        renderIds(currentIds);

        fileInput.value = "";
        selInfo.textContent = "";
        uploadBtn.disabled = true;
        showAlert("Pièce(s) jointe(s) ajoutée(s).");
        setStatus("");
      } catch (e) {
        console.error(e);
        setStatus("Erreur upload PJ (voir console).");
      }
    });

    row.appendChild(miniBtn);
    row.appendChild(uploadBtn);
    row.appendChild(fileInput);
    row.appendChild(selInfo);

    group.appendChild(label);
    group.appendChild(list);
    group.appendChild(row);
    wrap.appendChild(group);
    return wrap;
  }

  /** Choice : dropdown simple avec liste d'options */
  function renderChoiceField(ctx) {
    const { col, current, setValueToState, setInvalid, label, err, group, wrap } = ctx;

    const options = getChoiceOptions(col);
    if (!options.length) return renderTextField(ctx);

    const dd = document.createElement("div");
    dd.className = "dd-wrap";

    const input = document.createElement("input");
    input.className = "fr-input";
    input.type = "text";
    input.autocomplete = "off";

    const list = document.createElement("div");
    list.className = "dd-list";
    list.hidden = true;

    const cur = (current == null) ? "" : String(current);
    if (cur) input.value = cur;
    setValueToState(cur || null);

    function render(q) {
      list.innerHTML = "";
      const qq = (q || "").toLowerCase().trim();
      const matches = options.filter(o => !qq || o.toLowerCase().includes(qq)).slice(0, 50);
      for (const opt of matches) {
        list.appendChild(createDropdownItem({ label: opt }, () => {
          input.value = opt;
          setValueToState(opt);
          closeAllLists(null);
          setInvalid(input, null);
        }));
      }
      closeAllLists(list);
    }

    setupDropdownBehavior(input, render, col.colId === "Nationalite");

    dd.appendChild(input);
    dd.appendChild(list);
    group.appendChild(label);
    group.appendChild(dd);
    group.appendChild(err);
    wrap.appendChild(group);
    return wrap;
  }

  /** Ref : dropdown sur table referencee (selection simple) */
  function renderRefField(ctx) {
    const { col, current, setValueToState, setInvalid, label, err, group, wrap } = ctx;

    const dd = document.createElement("div");
    dd.className = "dd-wrap";

    const input = document.createElement("input");
    input.className = "fr-input";
    input.type = "text";
    input.autocomplete = "off";

    const list = document.createElement("div");
    list.className = "dd-list";
    list.hidden = true;

    // Init display (async)
    (async () => {
      const cache = await ensureRefCache(col);
      if (typeof current === "number") {
        const it = cache.byId.get(current);
        input.value = it ? it.label : String(current);
      } else if (typeof current === "string" && current.trim()) {
        input.value = current;
      }
    })();

    async function render(q) {
      const cache = await ensureRefCache(col);
      list.innerHTML = "";
      const qq = (q || "").toLowerCase().trim();
      const source = qq ? cache.rows.filter(r => r.q.includes(qq)) : cache.rows;
      const matches = source.slice(0, 25);

      for (const m of matches) {
        list.appendChild(createDropdownItem({ label: m.label, extra: m.extra }, () => {
          input.value = m.label;
          setValueToState(m.id);
          closeAllLists(null);
          setInvalid(input, null);
        }));
      }
      closeAllLists(list);
    }

    setupDropdownBehavior(input, render, col.colId === "Nationalite");

    dd.appendChild(input);
    dd.appendChild(list);
    group.appendChild(label);
    group.appendChild(dd);
    group.appendChild(err);
    wrap.appendChild(group);
    return wrap;
  }

  /** RefList : dropdown multi-selection sur table referencee */
  function renderRefListField(ctx) {
    const { col, current, setValueToState, label, group, wrap } = ctx;

    const dd = document.createElement("div");
    dd.className = "dd-wrap";

    const input = document.createElement("input");
    input.className = "fr-input";
    input.type = "text";
    input.autocomplete = "off";

    const list = document.createElement("div");
    list.className = "dd-list";
    list.hidden = true;

    let selectedIds = (isListCell(current) ? decodeListCell(current) : []).filter(x => typeof x === "number");

    async function refreshInput() {
      const cache = await ensureRefCache(col);
      const labels = selectedIds.map(id => cache.byId.get(id)?.label || String(id));
      input.value = labels.join(", ");
      setValueToState(["L", ...selectedIds]);
    }

    function toggleId(id) {
      const idx = selectedIds.indexOf(id);
      if (idx >= 0) selectedIds.splice(idx, 1);
      else selectedIds.push(id);
    }

    async function render(q) {
      const cache = await ensureRefCache(col);
      list.innerHTML = "";
      const qq = (q || "").toLowerCase().trim();

      const header = document.createElement("div");
      header.className = "dd-item";
      header.style.cursor = "default";
      header.innerHTML = `<div><strong>${selectedIds.length}</strong> sélectionné(s)</div><small>Clique pour cocher/décocher</small>`;
      list.appendChild(header);

      const source = qq ? cache.rows.filter(r => r.q.includes(qq)) : cache.rows;
      const matches = source.slice(0, 80);

      for (const m of matches) {
        list.appendChild(createDropdownItem(
          { label: m.label, extra: m.extra, hasCheckbox: true, checked: selectedIds.includes(m.id) },
          async () => {
            toggleId(m.id);
            await refreshInput();
            render(input.value);
          }
        ));
      }
      closeAllLists(list);
    }

    refreshInput();
    setupDropdownBehavior(input, render, col.colId === "Nationalite");

    dd.appendChild(input);
    dd.appendChild(list);
    group.appendChild(label);
    group.appendChild(dd);
    wrap.appendChild(group);
    return wrap;
  }

  /** ChoiceList : dropdown multi-selection avec checkboxes */
  function renderChoiceListField(ctx) {
    const { col, current, setValueToState, label, group, wrap } = ctx;

    const dd = document.createElement("div");
    dd.className = "dd-wrap";

    const input = document.createElement("input");
    input.className = "fr-input no-search";
    input.type = "text";
    input.placeholder = "Sélectionner…";
    input.autocomplete = "off";
    input.readOnly = true;

    const list = document.createElement("div");
    list.className = "dd-list";
    list.hidden = true;

    const wopts = col.widgetOptionsParsed || {};
    const choices = Array.isArray(wopts.choices) ? wopts.choices : [];
    let selected = decodeListCell(current).filter(v => typeof v === "string");

    function renderValue() {
      input.value = selected.join(", ");
      setValueToState(["L", ...selected]);
    }

    function renderList() {
      list.innerHTML = "";
      for (const c of choices) {
        list.appendChild(createDropdownItem(
          { label: c, hasCheckbox: true, checked: selected.includes(c) },
          () => {
            if (selected.includes(c)) selected = selected.filter(x => x !== c);
            else selected = [...selected, c];
            renderValue();
            renderList();
          }
        ));
      }
      closeAllLists(list);
    }

    renderValue();
    input.addEventListener("focus", () => renderList());
    input.addEventListener("click", () => renderList());

    dd.appendChild(input);
    dd.appendChild(list);
    group.appendChild(label);
    group.appendChild(dd);
    wrap.appendChild(group);
    return wrap;
  }

  /** Date : input date avec conversion timestamp Unix */
  function renderDateField(ctx) {
    const { col, current, setValueToState, label, err, group, wrap } = ctx;

    const input = document.createElement("input");
    input.className = "fr-input";
    input.type = "date";

    // Grist stocke les dates en timestamp Unix (secondes)
    if (current != null) {
      if (typeof current === "number") {
        const d = new Date(current * 1000);
        input.value = d.toISOString().slice(0, 10);
      } else {
        const s = String(current);
        input.value = s.includes("T") ? s.slice(0, 10) : s;
      }
    }

    input.addEventListener("input", () => {
      if (input.value) {
        // Convertir YYYY-MM-DD en timestamp Unix (secondes, midnight UTC)
        const d = new Date(input.value + "T00:00:00Z");
        setValueToState(Math.floor(d.getTime() / 1000));
      } else {
        setValueToState(null);
      }
    });

    group.appendChild(label);
    group.appendChild(input);
    group.appendChild(err);
    wrap.appendChild(group);
    return wrap;
  }

  /** Int / Numeric : input number */
  function renderIntField(ctx) {
    const { col, current, setValueToState, label, err, group, wrap } = ctx;

    const input = document.createElement("input");
    input.className = "fr-input";
    input.type = "number";
    input.value = (current != null) ? current : "";

    input.addEventListener("input", () => {
      const val = input.value.trim();
      if (val === "") {
        setValueToState(null);
      } else {
        const num = col.type === "Int" ? parseInt(val, 10) : parseFloat(val);
        setValueToState(isNaN(num) ? null : num);
      }
    });

    group.appendChild(label);
    group.appendChild(input);
    group.appendChild(err);
    wrap.appendChild(group);
    return wrap;
  }

  /** Bool : toggle DSFR (interrupteur Oui/Non) */
  function renderBoolField(ctx) {
    const { col, current, setValueToState, label, err, group, wrap } = ctx;

    const toggleWrap = document.createElement("div");
    toggleWrap.className = "fr-toggle";

    const tId = `toggle-${col.colId}-${Date.now()}`;

    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.id = tId;
    checkbox.className = "fr-toggle__input";
    checkbox.checked = !!current;

    const toggleLabel = document.createElement("label");
    toggleLabel.className = "fr-toggle__label";
    toggleLabel.setAttribute("for", tId);
    toggleLabel.setAttribute("data-fr-checked-label", "Oui");
    toggleLabel.setAttribute("data-fr-unchecked-label", "Non");
    toggleLabel.textContent = col.label;

    setValueToState(!!current);

    checkbox.addEventListener("change", () => {
      setValueToState(checkbox.checked);
    });

    toggleWrap.appendChild(checkbox);
    toggleWrap.appendChild(toggleLabel);

    group.appendChild(label);
    group.appendChild(toggleWrap);
    group.appendChild(err);
    wrap.appendChild(group);
    return wrap;
  }

  /** Text : input texte (fallback par defaut) */
  function renderTextField(ctx) {
    const { col, current, setValueToState, label, err, group, wrap } = ctx;

    const input = document.createElement("input");
    input.className = "fr-input";
    input.type = "text";
    input.value = current ?? "";

    input.addEventListener("input", () => {
      setValueToState(input.value || null);
    });

    group.appendChild(label);
    group.appendChild(input);
    group.appendChild(err);
    wrap.appendChild(group);
    return wrap;
  }

  /* ===== Type dispatch map ===== */
  const TYPE_HANDLERS = {
    "Attachments": renderAttachmentsField,
    "Choice":      renderChoiceField,
    "ChoiceList":  renderChoiceListField,
    "Date":        renderDateField,
    "Int":         renderIntField,
    "Numeric":     renderIntField,
    "Bool":        renderBoolField,
  };

  function getHandlerForType(typeStr) {
    if (TYPE_HANDLERS[typeStr]) return TYPE_HANDLERS[typeStr];
    const ref = parseRefType(typeStr);
    if (ref?.kind === "Ref") return renderRefField;
    if (ref?.kind === "RefList") return renderRefListField;
    return renderTextField;
  }

  /* ===== Rendering fields ===== */

  /**
   * Monte un groupe de colonnes dans un conteneur.
   * @param {string} containerId - ID du conteneur (ex: "fields-admin-perso")
   * @param {Array} cols - colonnes à rendre
   * @param {Set|null} readonlyCols - Set de colIds à rendre en lecture seule
   */
  function mountGroup(containerId, cols, readonlyCols) {
    const root = $(containerId);
    if (!root) return;
    root.innerHTML = "";

    if (!cols.length) {
      // Callout pour section vide
      const callout = document.createElement("div");
      callout.className = "fr-callout sub-empty-callout";
      callout.innerHTML = `<p class="fr-callout__text">Aucun champ configuré pour cette section.</p>`;
      root.appendChild(callout);
      return;
    }

    for (const col of cols) {
      try {
        const isReadonly = readonlyCols && readonlyCols.has(col.colId);
        const field = renderField(col, isReadonly);
        field.dataset.colid = col.colId;
        if (isReadonly) {
          field.classList.add("field-readonly");
          // Désactiver les inputs dans ce champ
          field.dataset.readonly = "true";
        }
        root.appendChild(field);
      } catch (e) {
        console.error("Render error for", col.colId, e);
        const warn = document.createElement("div");
        warn.className = "fr-alert fr-alert--warning fr-col-12";
        warn.style.marginBottom = "10px";
        warn.innerHTML = `<p class="fr-alert__title">Champ ignoré : ${escapeHtml(col.colId)}</p>
                          <p class="fr-alert__desc">Erreur au rendu. Voir la console.</p>`;
        root.appendChild(warn);
      }
    }
  }

  function renderField(col, isReadonly) {
    const wrap = document.createElement("div");
    wrap.className = "fr-col-12 fr-col-md-6 fr-col-lg-4 field-row";

    const group = document.createElement("div");
    group.className = "fr-input-group";

    // Label + hint popover
    const label = document.createElement("label");
    label.className = "fr-label";
    label.textContent = col.label;

    const wopts = col.widgetOptionsParsed || {};
    const hardcodedHints = { "AIE": "Accompagnant identifié et engagé" };
    const hintText = (wopts.hint || wopts.helpText || wopts.description)
      ? String(wopts.hint || wopts.helpText || wopts.description).trim()
      : ((col.description && String(col.description).trim()) ? String(col.description).trim() : (hardcodedHints[col.colId] || ""));

    if (hintText) {
      const hintWrap = document.createElement("span");
      hintWrap.className = "hint-wrap";

      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "fr-btn fr-btn--tertiary-no-outline fr-btn--sm hint-btn";
      btn.setAttribute("aria-label", "Afficher l'aide");

      const icon = document.createElement("span");
      icon.textContent = "?";
      icon.className = "hint-q";
      icon.setAttribute("aria-hidden", "true");
      btn.appendChild(icon);

      const pop = document.createElement("div");
      pop.className = "hint-pop";
      pop.hidden = true;
      pop.textContent = hintText;

      const show = () => { pop.hidden = false; };
      const hide = () => { pop.hidden = true; };
      btn.addEventListener("mouseenter", show);
      btn.addEventListener("focus", show);
      btn.addEventListener("mouseleave", hide);
      btn.addEventListener("blur", hide);
      pop.addEventListener("mouseenter", show);
      pop.addEventListener("mouseleave", hide);

      hintWrap.appendChild(btn);
      hintWrap.appendChild(pop);
      label.appendChild(hintWrap);
    }

    const err = document.createElement("p");
    err.className = "fr-error-text";
    err.hidden = true;

    let current = (selectedRecord && col.colId in selectedRecord) ? selectedRecord[col.colId] : null;

    function setValueToState(value) {
      // Les champs readonly ne doivent pas sauvegarder
      if (isReadonly) return;
      wrap.dataset.value = value == null ? "" : JSON.stringify(value);
    }
    if (!isReadonly) {
      setValueToState(current);
    }

    function setInvalid(el, message) {
      el.setAttribute("aria-invalid", message ? "true" : "false");
      if (message) { err.textContent = message; err.hidden = false; } else { err.hidden = true; }
    }

    // Dispatch vers le handler
    const ctx = { col, current, setValueToState, setInvalid, label, err, group, wrap };
    const handler = getHandlerForType(col.type);
    const result = handler(ctx);

    // Si readonly, désactiver tous les inputs/selects/textareas après le rendu
    if (isReadonly) {
      requestAnimationFrame(() => {
        for (const el of wrap.querySelectorAll("input, select, textarea")) {
          el.readOnly = true;
          el.disabled = true;
          el.tabIndex = -1;
        }
        for (const el of wrap.querySelectorAll("button")) {
          if (!el.classList.contains("hint-btn")) {
            el.disabled = true;
          }
        }
      });
    }

    return result;
  }

  /* ===== Collect & Save ===== */
  function collectPayload() {
    const payload = {};
    // Collecter uniquement les champs NON readonly
    const fields = $("formRoot").querySelectorAll("[data-colid]:not([data-readonly='true'])");
    for (const f of fields) {
      const colId = f.dataset.colid;
      const raw = f.dataset.value;
      if (raw === undefined) continue;
      let v = null;
      try { v = raw === "" ? null : JSON.parse(raw); } catch { v = raw; }
      if (v === "") v = null;
      // Éviter les doublons : ne prendre que la première occurrence
      if (!(colId in payload)) {
        payload[colId] = v;
      }
    }
    return payload;
  }

  async function loadCandidate(rowId) {
    hideAlert();
    setStatus("Chargement du candidat…");
    selectedRowId = rowId;

    const t = tableCache || await docApi.fetchTable(TABLE_ID);
    const idx = t.id.findIndex(x => x === rowId);
    if (idx < 0) {
      setStatus("Candidat introuvable.");
      return;
    }

    const rec = { id: rowId };
    for (const k of Object.keys(t)) {
      rec[k] = t[k][idx];
    }
    selectedRecord = rec;

    const nom = (rec["Nom_de_famille"] ?? "").toString();
    const prenom = (rec["Prenom"] ?? "").toString();
    const labelText = `${prenom} ${nom}`.trim() || `#${rowId}`;
    setSelectedPill(labelText);

    const tag = document.getElementById("candidateIdTag");
    if (tag) {
      const id2 = (rec["ID2"] != null && String(rec["ID2"]).trim() !== "") ? String(rec["ID2"]).trim() : null;
      tag.textContent = id2 ? `${id2}` : `${rowId}`;
      tag.title = "Cliquer pour copier";
      tag.onclick = async () => {
        try {
          await navigator.clipboard.writeText(tag.textContent);
          tag.classList.add("copied");
        } catch (e) {
          console.error(e);
          setStatus("Impossible de copier l'ID");
        }
      };
      tag.hidden = false;
    }

    $("emptyState").hidden = true;
    $("formRoot").hidden = false;
    $("saveBtn").disabled = false;

    renderFormForSelected();
    setStatus("");
  }

  /**
   * Remplit tous les conteneurs de champs dans les sous-sections de chaque onglet.
   * Parcourt TABS -> sections -> cols, filtre les colonnes existantes, et les monte.
   */
  function renderFormForSelected() {
    const editableMeta = columnsMeta.filter(isEditable);
    const metaByColId = new Map();
    for (const col of editableMeta) {
      metaByColId.set(col.colId, col);
    }

    // Pré-calculer le set de colonnes déjà rendues en tant que primaire
    // pour savoir quand un champ apparaît comme doublon (readonly)
    const primarySections = new Map(); // colId -> premier sectionId
    for (const tab of TABS) {
      for (const sec of tab.sections) {
        for (const colId of sec.cols) {
          if (!primarySections.has(colId)) {
            primarySections.set(colId, sec.id);
          }
        }
      }
    }

    for (const tab of TABS) {
      for (const sec of tab.sections) {
        const cols = [];
        const readonlyCols = new Set();

        for (const colId of sec.cols) {
          const meta = metaByColId.get(colId);
          if (!meta) continue; // colonne non trouvée dans le schéma

          cols.push(meta);

          // Vérifier si cette colonne est readonly ici
          const roSections = READONLY_IN[colId];
          if (roSections && roSections.has(sec.id)) {
            readonlyCols.add(colId);
          }
        }

        mountGroup(`fields-${sec.id}`, cols, readonlyCols);
      }

      // Mettre à jour les tags vides/non-vides
      updateTagStates(tab);
    }

    // Re-init DSFR pour les composants dynamiques (toggles, etc.)
    if (window.dsfr && typeof window.dsfr.start === "function") {
      window.dsfr.start();
    }
  }

  /**
   * Met à jour l'apparence des tags : ajoute .sub-tag--empty si la section
   * n'a aucun champ de données (seulement le callout "aucun champ").
   */
  function updateTagStates(tab) {
    const tagsContainer = $(`tags-${tab.id}`);
    if (!tagsContainer) return;

    const editableMeta = columnsMeta.filter(isEditable);
    const metaIds = new Set(editableMeta.map(c => c.colId));

    for (const tagEl of tagsContainer.querySelectorAll(".sub-tag")) {
      const secId = tagEl.dataset.sectionId;
      const sec = tab.sections.find(s => s.id === secId);
      if (!sec) continue;

      // Une section est "vide" si aucune de ses cols n'existe dans le schéma
      const hasFields = sec.cols.some(colId => metaIds.has(colId));
      tagEl.classList.toggle("sub-tag--empty", !hasFields && sec.cols.length === 0);
    }
  }

  async function save() {
    hideAlert();
    if (!selectedRowId) return;
    setStatus("Enregistrement…");

    const payload = collectPayload();
    try {
      await docApi.applyUserActions([["UpdateRecord", TABLE_ID, selectedRowId, payload]]);
      showAlert("Modifications enregistrées.");
      tableCache = await docApi.fetchTable(TABLE_ID);
      candidatesIndex = buildCandidateIndexFromTable(tableCache);
      setStatus("");
    } catch (e) {
      console.error(e);
      setStatus("Erreur d'enregistrement (voir console).");
    }
  }

  /* ===== Init ===== */
  async function init() {
    grist.ready({ requiredAccess: "full" });
    docApi = (typeof grist.docApi === "function") ? grist.docApi() : grist.docApi;

    $("closeAlert").addEventListener("click", hideAlert);
    $("saveBtn").addEventListener("click", save);

    setStatus("Chargement du schéma…");
    await refreshAttachmentsMap();
    columnsMeta = await loadColumnsMetaFor(TABLE_ID);

    // Mapping global (rowId -> colId) pour résoudre la Show column des références
    const allTables = await docApi.fetchTable("_grist_Tables");
    gristTableIdByParentId = new Map();
    for (let i = 0; i < allTables.id.length; i++) gristTableIdByParentId.set(allTables.id[i], allTables.tableId[i]);

    const allCols = await docApi.fetchTable("_grist_Tables_column");
    gristColIdByRowId = new Map();
    for (let i = 0; i < allCols.id.length; i++) gristColIdByRowId.set(allCols.id[i], { colId: allCols.colId[i], parentId: allCols.parentId[i] });

    setStatus("Indexation des candidats…");
    tableCache = await docApi.fetchTable(TABLE_ID);
    candidatesIndex = buildCandidateIndexFromTable(tableCache);

    // Construire les onglets (une seule fois)
    buildTabs();

    // Re-init DSFR pour les onglets dynamiques
    if (window.dsfr && typeof window.dsfr.start === "function") {
      window.dsfr.start();
    }

    setStatus("");

    const cs = $("candidateSearch");
    const clearBtn = $("clearSearchBtn");

    window.syncClearBtn = function syncClearBtn() {
      clearBtn.hidden = !(cs.value && cs.value.trim().length);
    };
    syncClearBtn();

    function clearSelection() {
      selectedRowId = null;
      selectedRecord = null;
      setSelectedPill("Aucun candidat sélectionné");
      const tag = document.getElementById("candidateIdTag");
      if (tag) { tag.hidden = true; tag.textContent = ""; tag.onclick = null; }
      $("formRoot").hidden = true;
      $("emptyState").hidden = false;
      $("saveBtn").disabled = true;
      hideAlert();
      setStatus("");
    }

    clearBtn.addEventListener("pointerdown", (e) => {
      e.preventDefault();
      e.stopPropagation();
      cs.value = "";
      syncClearBtn();
      closeAllLists(null);
      clearSelection();
      cs.focus();
    });

    cs.addEventListener("focus", () => { renderCandidateMatches(cs.value); syncClearBtn(); });
    cs.addEventListener("input", () => { renderCandidateMatches(cs.value); syncClearBtn(); });
    cs.addEventListener("pointerdown", (e) => { e.stopPropagation(); });

    grist.onRecord((rec) => {
      if (rec && rec.id) {
        if (!selectedRowId) {
          loadCandidate(rec.id);
          const nom = (rec["Nom_de_famille"] ?? "").toString();
          const prenom = (rec["Prenom"] ?? "").toString();
          cs.value = `${nom} ${prenom}`.trim();
        }
      }
    });
  }

  init().catch(err => {
    console.error(err);
    setStatus("Erreur d'initialisation : " + (err && err.message ? err.message : err));
  });

})();
</script>
</body>
</html>
